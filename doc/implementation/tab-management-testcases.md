# テストケース洗い出し: tab-management（タブ管理）

## 事前準備

本機能は chrome 拡張のタブ管理（NovelAI タブの検出・作成・アクティブ化）を担当します。設計と既存実装/テストを `/tdd-load-context` 相当で確認済み。

- 参照設計: `docs/design/novelai-auto-generator/architecture.md`（Service Worker がタブ制御）🟢
- 参照型定義: `docs/design/novelai-auto-generator/interfaces.ts`（メッセージ種別・全体モデル）🟡
- 参照データフロー: `docs/design/novelai-auto-generator/dataflow.md`（OPEN_OR_FOCUS_TAB 相当の流れ）🟢
- 類似TDD成果物: `docs/implements/TASK-030/*`（メモ/フェーズ資料）🟢

## 開発言語・フレームワーク

- プログラミング言語: TypeScript
  - 言語選択の理由: 既存コードベースと型定義の整合、Chrome API モックの型安全。🟢
  - テストに適した機能: ジェネリクス/ユニオン型でモックの表現力が高い。🟢
- テストフレームワーク: Vitest
  - フレームワーク選択の理由: 既存プロジェクト設定（`vitest.config.ts`）とテスト資産に整合。🟢
  - テスト実行環境: Node + jsdom（APIはモック）。🟢

## 1. 正常系テストケース

1) テスト名: 既存のNovelAIタブが見つかった場合にアクティブ化する
- 何をテストするか: `tabs.query` が既存タブを返したとき `tabs.update` でアクティブ化し、そのタブを返す。
- 期待される動作: 最初に検出したタブを `active: true` にして返す。
- 入力値: `tabs.query` → `[ { id:123, url:"https://novelai.net/generate", active:false } ]`
  - 入力データの意味: NovelAI タブがすでに存在する一般的ケース。
- 期待される結果: 返却値が `{ id:123, url:"...", active:true }`、`tabs.update` が `id=123` で1回呼ばれる。
  - 期待結果の理由: アーキテクチャ上、既存タブがあれば再利用する方針。🟢
- テストの目的: 検出→アクティブ化の基本フロー検証。
  - 確認ポイント: URLパターン、`update` 呼び出し、返却値の整合。
- 信頼性: 🟢（設計/既存実装に整合）

2) テスト名: NovelAIタブが存在しない場合に新しいタブを作成する
- 何をテストするか: `tabs.query` が空のとき `tabs.create` を呼び、新規タブを返す。
- 期待される動作: `create({ url:"https://novelai.net/", active:true })` が呼ばれ、そのタブが返る。
- 入力値: `tabs.query` → `[]`
  - 入力データの意味: 初回起動やすべてのタブを閉じた後のケース。
- 期待される結果: `tabs.create` 呼び出し1回、返却値一致。
  - 期待結果の理由: データフロー「OPEN_OR_FOCUS_TAB」の方針。🟢
- テストの目的: タブ新規作成の正当性。
  - 確認ポイント: URL/active 指定、返却整合。
- 信頼性: 🟢

3) テスト名: update が null を返す場合は元タブを返す
- 何をテストするか: `tabs.update` が `null` を返した場合のフォールバック。
- 期待される動作: 返却値は元の既存タブ（active:false→true 推定不能のため元タブ）。
- 入力値: `tabs.query` → `[ { id:10, url:"https://novelai.net/", active:false } ]`, `tabs.update` → `null`
  - 入力データの意味: 一部環境で `update` の返却が不定な場合の保護。
- 期待される結果: 例外なく元タブを返却。
  - 期待結果の理由: 既存実装がそのようにフォールバックしているため。🟢
- テストの目的: 不定返却時の堅牢性。
  - 確認ポイント: 例外非発生、返却値。
- 信頼性: 🟢

## 2. 異常系テストケース

4) テスト名: Chrome API が利用できない環境でエラーを投げる
- エラーケースの概要: `chrome` や `chrome.tabs` が未定義。
- エラー処理の重要性: 拡張外実行や誤ったテスト環境での明確な失敗。
- 入力値: `globalThis.chrome = undefined`
  - 不正な理由: API 前提に反する。
  - 実際の発生シナリオ: 単体テストや非Chrome環境の実行。
- 期待される結果: `"Chrome tabs API is not available"` を含む例外。
  - エラーメッセージの内容: 原因が即時に分かる。
  - システムの安全性: これ以上の処理を行わない。
- テストの目的: 事前条件チェックの検証。
  - 品質保証の観点: 環境依存性を可視化し、誤使用を防止。
- 信頼性: 🟢（実装と整合）

5) テスト名: 無効なタブデータ（id が null/undefined）でエラーを投げる
- エラーケースの概要: `tabs.query` が無効タブを返す。
- エラー処理の重要性: 後続の `update` を安全に回避するため。
- 入力値: `tabs.query` → `[ { id:null, url:"https://novelai.net/", active:false } ]`
  - 不正な理由: `update` に必要な `id` が欠落。
  - 実際の発生シナリオ: 稀な不整合やモック不備。
- 期待される結果: `"Invalid tab data received"` を含む例外。
  - エラーメッセージの内容: データ検証の失敗を明確化。
  - システムの安全性: 早期中断で安全側に倒す。
- テストの目的: 入力バリデーションの検証。
  - 品質保証の観点: 不整合データ耐性。
- 信頼性: 🟢（実装と整合）

## 3. 境界値テストケース

6) テスト名: 複数の既存タブが見つかった場合は最初のタブを選ぶ
- 境界値の意味: 検索結果が複数件のときの選択ルール。
- 境界値での動作保証: 先頭選択の一貫性。
- 入力値: `tabs.query` → `[{id:100,...},{id:101,...}]`
  - 境界値選択の根拠: 0件/1件/複数件の代表パターンのひとつ。
  - 実際の使用場面: 複数ウィンドウ/タブで NovelAI を開いている。
- 期待される結果: `update` は最初のタブ `id:100` に対して1回のみ呼ばれる。
  - 境界での正確性: 先頭固定で副作用が限定的。
  - 一貫した動作: 毎回同じ順序で選択。
- テストの目的: 優先順位ルールの明確化。
  - 堅牢性の確認: 他タブは影響なし。
- 信頼性: 🟡（一般的な優先規則の妥当推測）

7) テスト名: query が例外を投げた場合に伝播する
- 境界値の意味: 依存API失敗時の扱いを確認。
- 境界値での動作保証: 不用意に握りつぶさない。
- 入力値: `tabs.query` → `Promise.reject(new Error("query failed"))`
  - 境界値選択の根拠: API 層が失敗する最小ケース。
  - 実際の使用場面: 一時的なブラウザ不調など。
- 期待される結果: `ensureNovelAITab()` から例外がそのまま reject。
  - 境界での正確性: 呼び出し元の再試行戦略に委ねる。
  - 一貫した動作: 隠蔽しない（ロギングは上位で実施）。
- テストの目的: 例外伝播ポリシーの確認。
  - 堅牢性の確認: 予期しないサイレント失敗を回避。
- 信頼性: 🟡（設計方針からの妥当推測）

---

## テストケース実装時の日本語コメント指針（テンプレート）

テスト開始時:
```ts
// 【テスト目的】: ...
// 【テスト内容】: ...
// 【期待される動作】: ...
// 🟢🟡🔴 信頼性レベル: ...
```

Given:
```ts
// 【テストデータ準備】: ...
// 【初期条件設定】: ...
// 【前提条件確認】: ...
```

When:
```ts
// 【実際の処理実行】: ...
// 【処理内容】: ...
// 【実行タイミング】: ...
```

Then:
```ts
// 【結果検証】: ...
// 【期待値確認】: ...
// 【品質保証】: ...
```

各 expect:
```ts
expect(value).toBe(true); // 【検証項目】: ...（🟢🟡🔴）
```

---

## 品質判定

- テストケース分類: 正常系・異常系・境界値を網羅 → 充足
- 期待値定義: 具体的で検証ポイント明確 → 充足
- 技術選択: TypeScript + Vitest → プロジェクト整合
- 実装可能性: 既存のモックパターンに合致 → 容易

結論: ✅ 高品質

## 次のステップ

次のお勧めステップ: `/tdd-red tab-management` でRedフェーズ（失敗テスト作成）を開始します。

