# TDDテストケース - TASK-040: UI スケルトン/状態管理

**【機能名】**: Popup UI スケルトン/状態管理

## 開発言語・フレームワーク

- **プログラミング言語**: TypeScript
  - **言語選択の理由**: 既存プロジェクトのTypeScript環境との統一、型安全性による品質向上
  - **テストに適した機能**: 強い型付けによるテスト時のエラー早期発見、インターフェース活用による明確なテスト境界
- **テストフレームワーク**: Vitest
  - **フレームワーク選択の理由**: 既存プロジェクトで採用済み、Chrome Extension環境との互換性
  - **テスト実行環境**: Node.js + Chrome API モック環境（chrome.storage, chrome.runtime等をモック化）
- 🟢 既存プロジェクトの技術選択を踏襲し、技術的整合性を確保

## 1. 正常系テストケース（基本的な動作）

### 1.1 設定管理機能のテストケース

#### TC-001: 設定の初期化
- **テスト名**: 初回起動時の設定デフォルト値読み込み
  - **何をテストするか**: Popup初期化時にデフォルト設定値が正しく表示される
  - **期待される動作**: chrome.storage.localが空の場合にデフォルト値でUI要素が初期化される
- **入力値**: 空のchrome.storage.local
  - **入力データの意味**: 拡張機能初回インストール時の状態を模擬
- **期待される結果**:
  - imageCount: 1
  - seed: -1
  - filenameTemplate: "{date}_{prompt}_{seed}_{idx}"
  - **期待結果の理由**: REQ-005の設定要件とinterfaces.tsのデフォルト値定義に基づく
- **テストの目的**: 初期状態での安全な動作確認
  - **確認ポイント**: UI要素の値が設定されており、undefinedや空文字でない
- 🟢 要件定義書とinterfaces.tsの型定義から直接導出

#### TC-002: 設定の保存
- **テスト名**: ユーザー設定変更時の即座保存
  - **何をテストするか**: 設定値変更時にchrome.storage.localに正しく保存される
  - **期待される動作**: change イベント発生時に非同期でストレージ保存が実行される
- **入力値**:
  - imageCount: 5
  - seed: 12345
  - filenameTemplate: "custom_{date}_{idx}"
- **入力データの意味**: ユーザーが実際に設定する一般的な値
- **期待される結果**: chrome.storage.local.set()が適切なデータ構造で呼び出される
  - **期待結果の理由**: REQ-005の設定保存要件に基づく
- **テストの目的**: 設定の永続化機能確認
  - **確認ポイント**: ストレージAPIが正しい形式でデータを受け取る
- 🟢 要件定義書のREQ-005とpopup.jsの既存実装パターンに基づく

#### TC-003: 設定の復元
- **テスト名**: 既存設定値での起動時復元
  - **何をテストするか**: 保存済み設定値でPopup開いた時の値復元
  - **期待される動作**: chrome.storage.localから設定を読み取りUI要素に反映
- **入力値**:
  - chrome.storage.local: {settings: {imageCount: 3, seed: 999, filenameTemplate: "saved_{prompt}"}}
- **入力データの意味**: 以前に保存されたユーザー設定
- **期待される結果**: UI要素が保存済み値で初期化される
  - **期待結果の理由**: REQ-005の設定復元要件
- **テストの目的**: 設定の永続性確認
  - **確認ポイント**: DOM要素の値が保存データと一致
- 🟢 要件定義書とstorage.tsの実装パターンに基づく

### 1.2 メッセージ通信機能のテストケース

#### TC-004: 生成開始メッセージ送信
- **テスト名**: START_GENERATIONメッセージの正常送信
  - **何をテストするか**: 生成ボタン押下時の適切なメッセージ送信
  - **期待される動作**: 選択されたプロンプトと設定値でメッセージが構築・送信される
- **入力値**:
  - 選択プロンプト: '{"name":"テスト","prompt":"beautiful landscape"}'
  - 設定: {imageCount: 2, seed: 123}
- **入力データの意味**: 一般的な画像生成設定
- **期待される結果**: chrome.runtime.sendMessage()で適切なメッセージが送信される
  - **期待結果の理由**: REQ-006のメッセージ通信要件
- **テストの目的**: UI-Service Worker間通信の確認
  - **確認ポイント**: メッセージ形式がinterfaces.tsの型定義に準拠
- 🟢 要件定義書のREQ-006とmessaging-router.tsの実装パターンに基づく

#### TC-005: キャンセルメッセージ送信
- **テスト名**: CANCEL_JOBメッセージの正常送信
  - **何をテストするか**: キャンセルボタン押下時のジョブ停止要求
  - **期待される動作**: 現在のジョブIDでキャンセルメッセージが送信される
- **入力値**:
  - currentJob.id: "job-12345"
- **入力データの意味**: 実行中のジョブの識別子
- **期待される結果**: CANCEL_JOBタイプのメッセージが送信される
  - **期待結果の理由**: NFR-202のキャンセル機能要件
- **テストの目的**: ジョブ制御機能の確認
  - **確認ポイント**: ジョブIDが正確に含まれること
- 🟢 要件定義書のNFR-202とpopup.jsの既存実装に基づく

### 1.3 UI状態管理機能のテストケース

#### TC-006: UI状態の待機中表示
- **テスト名**: 待機状態でのUI表示制御
  - **何をテストするか**: 非生成時のUI要素表示状態
  - **期待される動作**: 生成ボタン表示、キャンセルボタン非表示、進捗セクション非表示
- **入力値**: isGenerating: false
- **入力データの意味**: アイドル状態
- **期待される結果**:
  - 生成ボタン: 表示
  - キャンセルボタン: 非表示
  - 進捗セクション: 非表示
  - ステータス: "待機中"
  - **期待結果の理由**: NFR-201のUI状態表示要件
- **テストの目的**: 基本UI状態管理の確認
  - **確認ポイント**: 要素の display プロパティが適切に設定される
- 🟢 要件定義書のNFR-201とpopup.htmlの既存UI構造に基づく

#### TC-007: UI状態の生成中表示
- **テスト名**: 生成状態でのUI表示制御
  - **何をテストするか**: 生成処理中のUI要素表示状態
  - **期待される動作**: 生成ボタン非表示、キャンセルボタン表示、進捗セクション表示
- **入力値**: isGenerating: true
- **入力データの意味**: 画像生成実行中の状態
- **期待される結果**:
  - 生成ボタン: 非表示
  - キャンセルボタン: 表示
  - 進捗セクション: 表示
  - ステータス: "生成中..."
  - **期待結果の理由**: NFR-201とNFR-202の要件
- **テストの目的**: 生成中UI状態の確認
  - **確認ポイント**: ユーザーが現在の状態を明確に認識できる
- 🟢 要件定義書とpopup.jsのupdateUI()実装に基づく

### 1.4 進捗表示機能のテストケース

#### TC-008: 進捗バー更新
- **テスト名**: GENERATION_PROGRESSメッセージでの進捗表示更新
  - **何をテストするか**: 進捗メッセージ受信時のプログレスバー更新
  - **期待される動作**: current/total比率でプログレスバーの幅が更新される
- **入力値**:
  - progress: {current: 3, total: 5, eta: 120}
- **入力データの意味**: 5枚中3枚完了、残り2分の進捗状況
- **期待される結果**:
  - プログレスバー幅: 60%
  - 進捗テキスト: "3 / 5"
  - ETA表示: "残り時間: 2分0秒"
  - **期待結果の理由**: NFR-201の進捗表示要件
- **テストの目的**: リアルタイム進捗表示の確認
  - **確認ポイント**: 視覚的に進捗が分かりやすく表示される
- 🟢 要件定義書のNFR-201とpopup.jsのupdateProgress()実装に基づく

### 1.5 ログ表示機能のテストケース

#### TC-009: ログエントリ追加
- **テスト名**: ログメッセージの正常追加と表示
  - **何をテストするか**: addLog()呼び出し時のログエントリ作成
  - **期待される動作**: 時刻付きでログコンテナにエントリが追加される
- **入力値**:
  - message: "設定を保存しました"
  - type: "info"
- **入力データの意味**: 一般的な操作完了メッセージ
- **期待される結果**:
  - ログエントリが追加される
  - 時刻が現在時刻で表示される
  - メッセージが正確に表示される
  - **期待結果の理由**: ユーザーへの操作フィードバック提供
- **テストの目的**: ログ機能の基本動作確認
  - **確認ポイント**: ログが時系列順で読みやすく表示される
- 🟢 popup.jsの既存addLog()実装とHTML構造に基づく

## 2. 異常系テストケース（エラーハンドリング）

### 2.1 ストレージエラーのテストケース

#### TC-010: ストレージ保存エラー
- **テスト名**: chrome.storage.local.set()失敗時のエラーハンドリング
  - **エラーケースの概要**: ストレージ容量不足や権限エラーでの保存失敗
  - **エラー処理の重要性**: ユーザー設定の消失防止とエラー状況の明確化
- **入力値**: chrome.storage.local.set()でPromise.reject()
- **不正な理由**: ストレージクォータ超過または権限不足
- **実際の発生シナリオ**: 長期使用でログ蓄積、または拡張機能権限変更時
- **期待される結果**:
  - エラーログ表示: "設定の保存に失敗しました"
  - console.errorでエラー詳細出力
  - UI状態は変更前のまま維持
  - **エラーメッセージの内容**: ユーザーが理解しやすい日本語メッセージ
  - **システムの安全性**: エラー発生時もUI操作は継続可能
- **テストの目的**: ストレージ障害時の堅牢性確認
  - **品質保証の観点**: データ損失防止とユーザー体験の継続性
- 🟢 要件定義書のストレージ障害対応とpopup.jsのエラーハンドリング実装に基づく

#### TC-011: ストレージ読み込みエラー
- **テスト名**: chrome.storage.local.get()失敗時のデフォルト値使用
  - **エラーケースの概要**: 初期化時のストレージアクセス失敗
  - **エラー処理の重要性**: アプリケーション起動の継続性確保
- **入力値**: chrome.storage.local.get()でPromise.reject()
- **不正な理由**: Chrome API一時的な障害または権限問題
- **実際の発生シナリオ**: ネットワーク不安定時やChrome起動直後
- **期待される結果**:
  - デフォルト値でUI初期化
  - エラーログ表示: "設定の読み込みに失敗しました。デフォルト値を使用します"
  - **エラーメッセージの内容**: 状況説明と自動復旧動作の説明
  - **システムの安全性**: 機能は制限なく利用可能
- **テストの目的**: 初期化エラー時の代替動作確認
  - **品質保証の観点**: 障害時でも基本機能が利用可能
- 🟢 要件定義書の設定ロード失敗対応とstorage.tsのエラーハンドリングに基づく

### 2.2 メッセージ通信エラーのテストケース

#### TC-012: メッセージ送信エラー
- **テスト名**: chrome.runtime.sendMessage()失敗時のエラーハンドリング
  - **エラーケースの概要**: Service Workerへのメッセージ送信失敗
  - **エラー処理の重要性**: ユーザーに失敗状況を明確に伝達し、再試行の機会を提供
- **入力値**: chrome.runtime.sendMessage()でPromise.reject()
- **不正な理由**: Service Worker非アクティブまたは拡張機能エラー
- **実際の発生シナリオ**: 拡張機能再読み込み直後やChromeメモリ不足時
- **期待される結果**:
  - エラーログ表示: "生成の開始に失敗しました: [エラー詳細]"
  - UI状態を元に戻す（isGenerating: false）
  - 生成ボタンを再度有効化
  - **エラーメッセージの内容**: エラー原因の推定と対処方法の提示
  - **システムの安全性**: UI状態の不整合を防止
- **テストの目的**: 通信障害時の状態整合性確認
  - **品質保証の観点**: エラー後の操作継続性とユーザビリティ
- 🟢 要件定義書のメッセージ不達対応とpopup.jsの既存エラーハンドリングに基づく

### 2.3 UI状態エラーのテストケース

#### TC-013: プロンプト未選択エラー
- **テスト名**: プロンプト未選択での生成開始試行
  - **エラーケースの概要**: 必須入力項目の不備での操作実行
  - **エラー処理の重要性**: ユーザーの操作ミス防止と適切なガイダンス提供
- **入力値**: promptSelect.value: ""（空文字）
- **不正な理由**: プロンプト選択が必須条件であるため
- **実際の発生シナリオ**: ユーザーが設定確認せずに生成ボタンを押下
- **期待される結果**:
  - エラーログ表示: "プロンプトを選択してください"
  - 生成処理は実行されない
  - プロンプト選択欄にフォーカス移動
  - **エラーメッセージの内容**: 明確な操作指示
  - **システムの安全性**: 不完全な条件での処理実行を防止
- **テストの目的**: 入力検証とユーザーガイダンス確認
  - **品質保証の観点**: ユーザビリティとデータ品質の確保
- 🟢 popup.jsの既存バリデーション実装とUX設計方針に基づく

## 3. 境界値テストケース（最小値、最大値、null等）

### 3.1 設定値境界のテストケース

#### TC-014: 画像枚数最小値
- **テスト名**: imageCount = 1での正常動作確認
  - **境界値の意味**: 生成可能な最小枚数で、これ以下は無意味
  - **境界値での動作保証**: 最小構成でも全機能が正常動作する
- **入力値**: imageCount: 1
- **境界値選択の根拠**: 要件定義での範囲仕様（1-10）の下限
- **実際の使用場面**: ユーザーが1枚のみの生成を行う一般的なケース
- **期待される結果**:
  - 設定保存が正常に実行される
  - 進捗表示が"1 / 1"で正しく表示される
  - 完了時の処理が正常実行される
  - **境界での正確性**: 単一要素での進捗計算が正確
  - **一貫した動作**: 複数枚設定時と同様の処理フロー
- **テストの目的**: 最小構成での機能完全性確認
  - **堅牢性の確認**: 極小値でもエラーや例外が発生しない
- 🟢 要件定義書のEDGE-102対応と入力仕様に基づく

#### TC-015: 画像枚数最大値
- **テスト名**: imageCount = 10での正常動作確認
  - **境界値の意味**: システムが処理可能な最大枚数の上限
  - **境界値での動作保証**: 最大負荷でも性能要件を満たす
- **入力値**: imageCount: 10
- **境界値選択の根拠**: 要件定義での範囲仕様（1-10）の上限
- **実際の使用場面**: ユーザーが大量生成を行う高負荷ケース
- **期待される結果**:
  - UI応答性が維持される（500ms以内の更新）
  - 進捗表示が"X / 10"で正確に更新される
  - メモリ使用量が適正範囲内
  - **境界での正確性**: 10段階の進捗更新が正確
  - **一貫した動作**: 少数枚設定時と同様の精度
- **テストの目的**: 最大負荷での性能・安定性確認
  - **堅牢性の確認**: 高負荷時でもメモリリークや処理遅延が発生しない
- 🟢 要件定義書のNFR-002性能要件とEDGE-102に基づく

#### TC-016: シード値境界テスト
- **テスト名**: seed = -1（ランダム）とseed = 0での動作確認
  - **境界値の意味**: ランダム生成指示と明示的シード値の境界
  - **境界値での動作保証**: 特殊値での処理分岐が正確
- **入力値**:
  - Case A: seed: -1
  - Case B: seed: 0
- **境界値選択の根拠**: -1はランダム指示の特殊値、0は有効な最小シード値
- **実際の使用場面**: ユーザーがランダム生成と固定シード生成を使い分ける
- **期待される結果**:
  - Case A: ランダムとして適切に処理される
  - Case B: 固定シード0として適切に処理される
  - ファイル名テンプレートで正しく展開される
  - **境界での正確性**: シード値の解釈が仕様通り
  - **一貫した動作**: ファイル名生成で混同されない
- **テストの目的**: シード値処理ロジックの境界確認
  - **堅牢性の確認**: 特殊値と通常値の処理が明確に分離される
- 🟢 要件定義書の入力仕様とTASK-011ファイル名テンプレート実装に基づく

### 3.2 文字列境界のテストケース

#### TC-017: ファイル名テンプレート空文字
- **テスト名**: filenameTemplate = ""での代替処理
  - **境界値の意味**: 必須項目の最小値（空）での代替動作
  - **境界値での動作保証**: 不正入力時の安全な代替動作
- **入力値**: filenameTemplate: ""
- **境界値選択の根拠**: 空文字は最小文字列で、実用上は無効
- **実際の使用場面**: ユーザーの入力ミスや設定破損時
- **期待される結果**:
  - デフォルトテンプレート値に自動復元
  - 警告ログ表示: "ファイル名テンプレートが空のため、デフォルト値を使用します"
  - 機能は正常に継続
  - **境界での正確性**: 空文字検出と代替処理が確実
  - **一貫した動作**: 他の文字列境界でも同様の安全性
- **テストの目的**: 入力値検証と代替処理の確認
  - **堅牢性の確認**: 不正入力でもシステムが停止しない
- 🟡 要件定義書のNFR-103入力サニタイズとTASK-011の境界処理に基づく

#### TC-018: ログエントリ上限テスト
- **テスト名**: ログエントリ50件到達時の古いエントリ削除
  - **境界値の意味**: ログ表示機能の容量上限と循環処理
  - **境界値での動作保証**: メモリ使用量の制限と表示性能の維持
- **入力値**: 連続51件のログメッセージ
- **境界値選択の根拠**: popup.jsの実装で50件上限が設定済み
- **実際の使用場面**: 長時間使用時のログ蓄積
- **期待される結果**:
  - 最新50件のみ表示される
  - 最古のエントリが自動削除される
  - DOM要素数が50を超えない
  - **境界での正確性**: 削除タイミングと件数が正確
  - **一貫した動作**: パフォーマンス劣化が発生しない
- **テストの目的**: ログ管理機能の境界動作確認
  - **堅牢性の確認**: 長時間使用でもメモリリークしない
- 🟢 popup.jsの既存ログ管理実装に基づく

### 3.3 null/undefined境界のテストケース

#### TC-019: 進捗データnull受信
- **テスト名**: GENERATION_PROGRESSでprogress: nullの場合
  - **境界値の意味**: 必須データの欠損時の安全な処理
  - **境界値での動作保証**: 不正メッセージでもUI破綻しない
- **入力値**:
  - message: {type: "GENERATION_PROGRESS", progress: null}
- **境界値選択の根拠**: nullは参照型の最小値で、実際のエラーで発生可能
- **実際の使用場面**: Service Workerの異常やメッセージ送信エラー時
- **期待される結果**:
  - エラーログ表示: "進捗データが不正です"
  - UI状態は前回値を維持
  - アプリケーションは継続動作
  - **境界での正確性**: null検出と安全な無視処理
  - **一貫した動作**: 他のnull値でも同様の安全性
- **テストの目的**: メッセージデータ検証の確認
  - **堅牢性の確認**: 不正データでもクラッシュしない
- 🟡 要件定義書のメッセージ不達対応とTypeScript型安全性に基づく

#### TC-020: chrome APIオブジェクトundefined
- **テスト名**: chrome.storage未定義環境での動作
  - **境界値の意味**: Chrome Extension環境外での実行時の安全性
  - **境界値での動作保証**: 依存API不在時の代替動作
- **入力値**: chrome: undefined
- **境界値選択の根拠**: 通常のWebページや開発環境でchrome APIは未定義
- **実際の使用場面**: テスト環境やデバッグ時の実行
- **期待される結果**:
  - エラーログ表示: "Chrome Extension環境が必要です"
  - 機能は無効化されるが例外は発生しない
  - UIは表示されるが操作は制限される
  - **境界での正確性**: API存在確認と条件分岐が確実
  - **一貫した動作**: 他のChrome APIでも同様の防御
- **テストの目的**: 実行環境依存性の確認
  - **堅牢性の確認**: 環境不備でもGraceful degradation
- 🟡 Chrome Extension開発のベストプラクティスとエラーハンドリング設計に基づく

## 実装時のコメント指針

### テストケース開始時のコメント例

```typescript
// 【テスト目的】: 初回起動時にデフォルト設定値でUI要素が正しく初期化されることを確認
// 【テスト内容】: chrome.storage.localが空の状態でPopup初期化処理を実行
// 【期待される動作】: 各UI要素（imageCount, seed, filenameTemplate）にデフォルト値が設定される
// 🟢 要件定義書のREQ-005とinterfaces.tsの型定義から直接導出
```

### Given/When/Then段階のコメント例

```typescript
describe('UI スケルトン/状態管理', () => {
  beforeEach(() => {
    // 【テスト前準備】: Chrome API モックの初期化と DOM 要素の準備
    // 【環境初期化】: 各テストが独立して実行できるよう、状態をクリーンにリセット
  });

  test('TC-001: 初回起動時の設定デフォルト値読み込み', async () => {
    // 【テストデータ準備】: 空のストレージ状態を模擬（初回インストール時を想定）
    // 【初期条件設定】: chrome.storage.localを空オブジェクトでモック化
    // 【前提条件確認】: DOM要素が存在し、イベントリスナーが未設定であることを確認
    const mockStorage = {};
    chrome.storage.local.get.mockResolvedValue(mockStorage);

    // 【実際の処理実行】: Popup初期化処理（loadSettings関数）を呼び出し
    // 【処理内容】: ストレージからの設定読み込みとUI要素への反映を実行
    // 【実行タイミング】: DOMContentLoaded後のタイミングを模擬
    await loadSettings();

    // 【結果検証】: UI要素の値がデフォルト値と一致することを確認
    // 【期待値確認】: REQ-005で定義されたデフォルト値との整合性確認
    // 【品質保証】: 初期化処理の信頼性とユーザー体験の一貫性確保

    // 【検証項目】: 画像枚数入力欄のデフォルト値確認
    // 🟢 interfaces.tsのGenerationSettings型定義に基づく
    expect(elements.imageCount.value).toBe('1');

    // 【検証項目】: シード値入力欄のデフォルト値確認
    // 🟢 要件定義書の入力仕様に基づく
    expect(elements.seed.value).toBe('-1');

    // 【検証項目】: ファイル名テンプレート入力欄のデフォルト値確認
    // 🟢 TASK-011のテンプレート仕様に基づく
    expect(elements.filenameTemplate.value).toBe('{date}_{prompt}_{seed}_{idx}');
  });

  afterEach(() => {
    // 【テスト後処理】: モック状態のリセットとグローバル変数の初期化
    // 【状態復元】: 次のテストが前回の実行結果に影響されないよう環境をクリーン化
  });
});
```

## 品質判定

✅ **高品質**:
- **テストケース分類**: 正常系（9件）・異常系（4件）・境界値（7件）で合計20件のテストケースを網羅的に定義
- **期待値定義**: 各テストケースで具体的な入力値・期待される結果・検証ポイントを明確化
- **技術選択**: TypeScript + Vitest を確定し、Chrome Extension環境に適したモック戦略を策定
- **実装可能性**: 既存のプロジェクト構造（storage.ts、messaging-router.ts、popup.js）と整合した現実的なテストケース

## 次のステップ

次のお勧めステップ: `/tdd-red` でRedフェーズ（失敗テスト作成）を開始します。